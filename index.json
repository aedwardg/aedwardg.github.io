[{"content":" TL;DR: Snails are really Rubik\u0026rsquo;s Cubes in disguise\n I\u0026rsquo;m not the type of person who loves algorithmic coding \u0026ldquo;challenges\u0026rdquo; for their own sake. Some of them can be fun (shoutout to Advent of Code), but nine times out of ten, I\u0026rsquo;d rather work on actual projects. That said, I do think such challenges are an excellent way to learn the ins and outs of a new programming language.\nRecently, I\u0026rsquo;ve been exploring functional programming languages as a way to expand the way I think about problem solving, and to force myself out of my comfort zone. In particular, I\u0026rsquo;ve gravitated toward Elixir, which has proven particularly suited to some coding challenges and rather tricky for others.\nHaving to think in terms of recursion, pipelines and reducers for every problem certainly causes friction when you\u0026rsquo;re used to imperative programming, but sometimes this friction leads to discovering a much more elegant solution. A perfect example of this is the fun (but probably useless) sorting algorithm problem: the Snail Sort.\nWhat is \u0026ldquo;Snail Sort\u0026rdquo; anyway? # Image from Codewars  The Snail Sort is a sorting algorithm challenge found on sites such as Codewars. The idea is to come up with an algorithm that takes a 2D array and returns a flattened array, sorted in a clockwise spiral order, reminiscent of the spiral on a snail\u0026rsquo;s shell.\nSo, as can be seen from the image above, if given the following 2D array\u0026hellip;\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]] \u0026hellip;your algorithm should return an single, flat array in this order:\n[1, 2, 3, 6, 9, 8, 7, 4, 5] The Naïve Approach # In an imperative language, most people (myself included) would jump at the naïve procedural approach and call it a day:\n Take the top row (first inner array). For the length of the outer array, take the last element each inner array. Take the last inner array, reversed. Traversing backward over the outer array, take the first element of each inner array Repeat until empty.  And while there is nothing wrong with this approach, I do think it is telling that this article is the top Google result for \u0026ldquo;Snail Sort\u0026rdquo; \u0026ndash; this is simply the way that most of us are used to thinking.\nAttempting the procedural method in Elixir # In my initial attempt at solving this problem with Elixir, I\u0026rsquo;ll be the first to admit I immediately tried to apply the five steps listed above. However, attempting to translate procedural solutions to a functional programming language can be tricky \u0026mdash; even uncomfortable! \u0026mdash; and feels much like fitting a square peg into a round hole.\nFor starters, you don\u0026rsquo;t have traditional loops, so you need to make the decision early on how you\u0026rsquo;re going to \u0026ldquo;loop\u0026rdquo; through the arrays. Recursion? Reduce? Comprehension? Then, to make things even more complicated, all lists in Elixir are implemented as linked lists, so accessing elements in a list occurs in linear time. Want to get the last element in the list? Cool, that\u0026rsquo;ll be O(n).\nWith this in mind, I decided to use a combination of recursion and Enum.reduce/3 in my first solution. Below is a high-level summary of my process:\n Write a recursive function for a single rotation of the \u0026ldquo;spiral\u0026rdquo;. Break each step of the spiral into its own function that reduces the matrix (if needed). Each function accepts and returns a tuple containing a) the remaining matrix, and b) the new, sorted list.  This makes the functions easily pipeable and allows for easy pattern matching to determine if the matrix is empty at any step and exit the recursive loop (because Elixir doesn\u0026rsquo;t have return or break keywords).    defmodule Snail do def snail(matrix) do sort(matrix, []) end defp sort([], sorted), do: List.flatten(sorted) defp sort([head | tail], sorted) do sorted = sorted ++ head matrix = tail {matrix, sorted} = add_last_nums({matrix, sorted}) |\u0026gt; add_bottom_row |\u0026gt; add_first_nums sort(matrix, sorted) end defp add_last_nums({[], _} = done), do: done defp add_last_nums({matrix, sorted}) do matrix |\u0026gt; Enum.reduce({[], sorted}, fn l, {m, s} -\u0026gt; {i, l} = l |\u0026gt; List.pop_at(-1) {[l | m], s ++ [i]} end) end defp add_bottom_row({[], _} = done), do: done defp add_bottom_row({[head | tail], sorted}) do {tail, sorted ++ Enum.reverse(head)} end defp add_first_nums({[], _} = done), do: done defp add_first_nums({matrix, sorted}) do matrix |\u0026gt; Enum.reduce({[], sorted}, fn l, {m, s} -\u0026gt; [i | l] = l {[l | m], s ++ [i]} end) end end Ultimately, I\u0026rsquo;m not upset with this solution. It works, and it\u0026rsquo;s fairly easy to see when each step occurs and what happens in each step. That said, while writing it I couldn\u0026rsquo;t shake the feeling that there had to be a better way. It wasn\u0026rsquo;t until about halfway through that I figured out the approach I should have taken from the start.\nA More Elegant Solution # Photo by Honey Yanibel Minaya Cruz on Unsplash  So far in my journey to learning Elixir, I\u0026rsquo;ve discovered a trend that shows up whenever I try to solve a problem the same way I would in an imperative language. First, I get extremely frustrated because the tools I\u0026rsquo;m looking for are either not a part of the language or, if they are, they feel awkward to use.\nNext, I try to bend the language to my will, only to find myself unsatisfied with the result. Oddly enough, the syntax and implementation of Elixir feel like they want to guide the programmer to solve some problems in a very specific (and often more efficient) way.\nUltimately, I end up taking a step back and looking at the problem from a different perspective. For me, this mindset shift often ends in an \u0026ldquo;aha!\u0026rdquo; moment and it certainly did in this case.\nSnails are Rubik\u0026rsquo;s Cubes # If you take a closer look at the snail sort diagram above, you might notice that the matrix we\u0026rsquo;re tasked with traversing looks suspiciously like one face of a Rubik\u0026rsquo;s Cube.\nWith this in mind, it becomes abundantly clear that all you need to do is take the first row, rotate the cube 90 degrees to the left and repeat (!!!) until there is nothing left to remove.\nThat\u0026rsquo;s it! No popping the last element of the lists, no traversing backwards \u0026ndash; just \u0026ldquo;twist, remove, twist, remove\u0026rdquo; until it\u0026rsquo;s empty.\nAnd the best part? It\u0026rsquo;s not even difficult to implement. Take a look at the following code (adapted from @simonvpe\u0026rsquo;s Codewars solution), which shows just how easily and elegantly this can be accomplished in Elixir:\ndefmodule Matrix do def horizontal_reflect(m), do: m |\u0026gt; Enum.reverse def transpose(m), do: m |\u0026gt; List.zip |\u0026gt; Enum.map(\u0026amp;Tuple.to_list(\u0026amp;1)) def rotate_left(m), do: m |\u0026gt; transpose |\u0026gt; horizontal_reflect end defmodule Snail do def snail([]), do: [] def snail([h | t]), do: h ++ (t |\u0026gt; Matrix.rotate_left |\u0026gt; snail) end  Click here for a breakdown of what this code does! :mag: On a high level, what happens here is a matrix is passed to Snail.snail, which returns the head (first sub-list) prepended to the result of the tail (remaining sub-lists), rotated to the left and passed recursively back to Snail.snail\nMatrix.rotate_left works by taking a matrix and converting the columns into the rows, and then flipping the new matrix across the x-axis like so:\n# original matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # after the matrix has been transposed (columns into rows): [[1, 4, 7], [2, 5, 8], [3, 6, 9]] # after the transposed matrix has been flipped over the x-axis: [[3, 6, 9], [2, 5, 8], [1, 4, 7]] So, if we take the top row and put it into a new list before each rotation, we get the following:\n# original matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] result = [] # step 1 [[4, 5, 6], [7, 8, 9]] result = [1, 2, 3] # after rotation 1: [[6, 9], [5, 8], [4, 7]] result = [1, 2, 3] # step 2 [[5, 8], [4, 7]] result = [1, 2, 3, 6, 9] # after rotation 2: [[8, 7], [5, 4]] result = [1, 2, 3, 6, 9] # step 3 [[5, 4]] result = [1, 2, 3, 6, 9, 8, 7] # after rotation 3 [[4], [5]] result = [1, 2, 3, 6, 9, 8, 7] # step 4 [[5]] result = [1, 2, 3, 6, 9, 8, 7, 4] # afer rotation 4 [[5]] result = [1, 2, 3, 6, 9, 8, 7, 4] # step 5 [] result = [1, 2, 3, 6, 9, 8, 7, 4, 5]   Click here to try it live in a REPL! :computer:   Conclusion # I don\u0026rsquo;t really have any closing remarks, other than hoping this change of perspective is as game-changing for someone else as it was for me. I\u0026rsquo;m in the business of sharing knowledge, and this felt a little too good not to share.\nI don\u0026rsquo;t expect to become a functional programming expert overnight, and I recognize that this paradigm might not be the best for every problem. But, if I were to verbalize my goal for the near-future, it would probably look something like this:\n Be the one who spins the cube, not the one who walks all the way around it.\n :snail:\n","date":"23 May 2022","permalink":"/posts/snail-sort-elixir/","section":"Posts","summary":"TL;DR: Snails are really Rubik\u0026rsquo;s Cubes in disguise","title":"How to Snail Sort (the Right Way)"},{"content":" TL;DR\u0026hellip;basically .format() for JavaScript\n These days, when developers need to piece strings together or represent non-string values in string format, most reach immediately for string interpolation when it\u0026rsquo;s available. It makes sense\u0026mdash;most of the time, string interpolation is not only the best approach, it\u0026rsquo;s also the most readable. That said, string interpolation can feel a little restrictive when you realize that the interpolation can only happen once: at the point of initialization.\nYou might be wondering: when would you need the interpolation to happen at a time other than when the string is initialized? The answer, in my experience, is rarely. However, when you do need it, it\u0026rsquo;s really frustrating when the programming language you\u0026rsquo;re using *cough* JavaScript *cough* doesn\u0026rsquo;t support it out of the box.\nPython Example # A great way to demonstrate this restriction is to take a look at Python\u0026rsquo;s f-strings (introduced in Python 3.6) and compare them with how string formatting was done prior to their addition to the language.\nFor those unfamiliar with f-strings, they allow string interpolation with the following syntax:\nname = \u0026#34;Bob\u0026#34; origin = \u0026#34;Canada\u0026#34; greeting = f\u0026#34;Hello, {name}from {origin}!\u0026#34; print(greeting) # prints \u0026#34;Hello, Bob from Canada!\u0026#34; Before the advent of f-strings, Pythonistas had to choose from a few different (and less readable) options, such as:\n# 1. string concatenation greeting = \u0026#34;Hello, \u0026#34; + name + \u0026#34; from \u0026#34; + origin + \u0026#34;!\u0026#34; # 2. C-style string formatting greeting = \u0026#34;Hello, %sfrom %s!\u0026#34; % (name, origin) # 3. The str.format() method (shown here with indexes) greeting = \u0026#34;Hello, {0}from {1}!\u0026#34;.format(name, origin) One of the benefits of the latter two approaches, however, was that you could define your string with placeholders beforehand, and then perform the formatting later with whatever values you wanted to:\n# Define your greeting string: greeting = \u0026#34;Hello, {0}from {1}!\u0026#34; # Set some variables name = \u0026#34;Bob\u0026#34; origin = \u0026#34;Canada\u0026#34; # Format your string print(greeting.format(name, origin)) # prints \u0026#34;Hello, Bob from Canada!\u0026#34; # Change the variable values name = \u0026#34;Sally\u0026#34; origin = \u0026#34;Kansas\u0026#34; # Use the same string and format with new values print(greeting.format(name, origin)) # prints \u0026#34;Hello, Sally from Kansas!\u0026#34; Trying to run something similar with classic string interpolation of course doesn\u0026rsquo;t work:\n# Running this: greeting = f\u0026#34;Hello, {name}from {origin}!\u0026#34; name = \u0026#34;Bob\u0026#34; origin = \u0026#34;Canada\u0026#34; # Results in this: Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: name \u0026#39;name\u0026#39; is not defined Building .format() in JavaScript # So what do you do when you want functionality similar to Python\u0026rsquo;s str.format() method in JavaScript?\nYou build it yourself.\nThere are a number of different approaches to take here\u0026mdash;including hacking directly into the String prototype\u0026mdash;but personally, I find the most interesting (and mind-bending) approach to use the ES6 feature of template strings called tagged templates.\nWhat are tagged templates? # If you\u0026rsquo;ve never heard of tagged templates, you\u0026rsquo;re in good company. They\u0026rsquo;re far from the most commonly used ES6 feature, in part because they can be difficult to wrap your head around. At their core, tagged templates are just template literals, parsed by a function.\nThe syntax looks like this:\nconst taggedTemplate = myTag`Some template literal here`; In the example above, the myTag function receives one argument: an array containing the string from the template literal. The taggedTemplate variable is then set to whatever value the myTag function returns.\nWhat\u0026rsquo;s special about the tagged template syntax, however, is that if the template literal contains any interpolation-like syntax (e.g., ${name}), the myTag function will instead receive multiple arguments: an array of the string, split at every instance of ${}, followed by an argument for every \u0026ldquo;key\u0026rdquo; provided within the curly braces.\nFor example, in the tagged template below\u0026hellip;\nmyTag`This is test number ${\u0026#39;num\u0026#39;}on day ${\u0026#39;day\u0026#39;}.` \u0026hellip;the myTag function will be called like so:\nmyTag([\u0026#39;This is test number \u0026#39;, \u0026#39; on day \u0026#39;, \u0026#39;.\u0026#39;], \u0026#39;num\u0026#39;, \u0026#39;day\u0026#39;) Using tagged templates to make a dynamic formatter # Knowing this, we can make a tagged template that acts similar to the str.format() method. For somewhat basic functionality, we know that we need the following:\n Our tag function should work with template literals that use any number of placeholder values. If given more than one value, we should have a way to specify which value is used with which placeholder. Formatting should be invoked at any time, like a function call. Ultimately, we should return a string after formatting has been invoked.  Build from the outside-in # To start, we know that no matter what, tag functions will always be passed an array of strings as the first argument. So our function can begin with something like this:\nfunction format(strings) { // do something } We also know that the rest of the arguments will be the placeholders from the template literal. To capture all of these in an array for later use, we will update our function with the ES6 ... operator:\nfunction format(strings, ...keys) { // do something } At this point, we can test our format tag and print out strings and keys to make sure we know what is going on.\nfunction format(strings, ...keys) { console.log(\u0026#34;Strings\u0026#34;, strings); console.log(\u0026#34;Keys\u0026#34;, keys); } const test = format`Hello ${\u0026#39;name\u0026#39;}! This is test ${1}.` In the terminal we see the output of our console.log() calls:\nStrings [ \u0026#39;Hello \u0026#39;, \u0026#39;! This is test \u0026#39;, \u0026#39;.\u0026#39; ] Keys [ \u0026#39;name\u0026#39;, 1 ] Make use of placeholders # To achieve goal #2 (specifying which value to use in each part of the string) we will have to utilize our placeholder keys. Since numeric keys come through as numbers, it\u0026rsquo;s clear that implementing an index-based placeholder system will be fairly straightforward, assuming we pass in an array of values:\n Map over each string, keeping track of the index To each string, add the value at the index specified by the key (if the key is 2, add the value at index 2 to the string)  Note: the index of the key will be the same index as the current string   Join all strings in the array and return the resulting string.  Roughly, we might want it to function something like this:\nconst values = [\u0026#34;world\u0026#34;, 2]; function format(strings, ...keys) { return strings .map((str, i) =\u0026gt; `${str}${values[keys[i]]}`) .join(\u0026#39;\u0026#39;); } const test = format`Hello ${0}! This is test ${1}.`; console.log(test); // prints \u0026#34;Hello world! This is test 2.undefined\u0026#34; Almost! We forgot to account for when our strings array is longer than our keys array. In the above example, the final iteration of our map tries to access values[keys[2]], which is undefined. A simple fix brings us to a working formatter:\nconst values = [\u0026#34;world\u0026#34;, 2]; function format(strings, ...keys) { return strings .map((str, i) =\u0026gt; `${str}${values[keys[i]] || \u0026#39;\u0026#39;}`) .join(\u0026#39;\u0026#39;); } const test = format`Hello ${0}! This is test ${1}.`; console.log(test); // prints \u0026#34;Hello world! This is test 2.\u0026#34; Convert to closure # Thus far we\u0026rsquo;ve managed to build a tagged template that meets goals 1, 2 and 4, but we still had to define our values before initializing it as test. So how can we change this to allow for passing in a set of values at any time?\nWe need to convert our tagged template from something that returns a string to something that returns a function.\n Note: The following pattern will look familiar to some of you, but will be completely foreign to others. If you haven\u0026rsquo;t heard of closures in JavaScript or need to brush up on them again, I highly recommend the Scopes and Closures chapter in Kyle Simpson\u0026rsquo;s book series, You Don\u0026rsquo;t Know JS Yet.\n Syntactically, this is a trivial change, but it\u0026rsquo;s important to take a second to fully understand what\u0026rsquo;s going on in the resulting code:\nfunction format(strings, ...keys) { return (...values) =\u0026gt; strings .map((str, i) =\u0026gt; `${str}${values[keys[i]] || \u0026#39;\u0026#39;}`) .join(\u0026#39;\u0026#39;); } const greetingTest = format`Hello ${0}! This is test ${1}.`; console.log(greetingTest(\u0026#39;world\u0026#39;, 3)); // prints \u0026#34;Hello world! This is test 3.\u0026#34; Here we are assigning the return value of our tagged template to the name greetingTest.\nThe tagged template returns a function that: a) accepts any number of values; and b) returns a string composed of the strings in our template literal and the values passed to the function.\nThe values are inserted into the resulting string based on the index specified by the placeholder keys in the template literal.\nAnd finally, the values given to greetingTest do not need to be predefined. They can be provided on the fly.\nOf course, we don\u0026rsquo;t need to assign the tagged template to a variable or constant to invoke it. The last two lines could be swapped out for this:\nconsole.log(format`Hello ${0}! This is test ${1}.`(\u0026#39;world\u0026#39;, 3)) Final Code # After a bit of work, we have a perfectly functional equivalent to Python\u0026rsquo;s .format in just a few lines of JavaScript:\nfunction format(strings, ...keys) { return (...vals) =\u0026gt; strings .map((str, i) =\u0026gt; `${str}${vals[keys[i]] || \u0026#39;\u0026#39;}`) .join(\u0026#39;\u0026#39;); } One noticeable difference from Python\u0026rsquo;s .format() is that in Python we can create an actual string variable with placeholders in it and call the .format() method on that variable later.\nWith our solution, we instead save the resulting function of the tagged template string, and invoke that function directly.\nBut in the end, the usage isn\u0026rsquo;t all that different between the two implementations:\nPython # greeting = \u0026#34;Greetings from the year {1}, {0}!\u0026#34; name = \u0026#34;Human\u0026#34; year = 2222 # Greetings from the year 2222, Human! print(greeting.format(name, year)) JavaScript # // `format` defined previously const greeting = format`Greetings from the year ${1}, ${0}!`; const name = \u0026#34;Human\u0026#34;; const year = 2222; // Greetings from the year 2222, Human! console.log(greeting(name, year)); While it\u0026rsquo;s not quite as powerful as its Python counterpart, it accomplishes what we set out to do.\nIf you\u0026rsquo;re interested, you can try it out using the REPL below, and you can even try implementing keywords by following the second example in the Mozilla documentation.\n Click here to try it live in a REPL   ","date":"13 March 2022","permalink":"/posts/string-formatting-js/","section":"Posts","summary":"TL;DR\u0026hellip;basically .","title":"String Formatting in JavaScript"},{"content":"Over the years I\u0026rsquo;ve made several attempts to keep a blog, but they\u0026rsquo;ve all more or less fallen somewhere on the spectrum of failure. Perhaps I should lower my standards and call a blog a success if it reaches more than two posts. I think at that point I may be the proud author of two successful blogs (give or take one\u0026hellip;it\u0026rsquo;s been a while).\nThis is all to say that blogging is hard to keep up with—particularly if you\u0026rsquo;re working with tooling that isn\u0026rsquo;t intuitive and painless. You already have the hurdle of putting your thoughts into coherent sentences working against you, why make it harder on yourself by using insufficient tools for your needs? Hence my switch to Hugo for this second attempt at a developer blog. I\u0026rsquo;m mildly optimistic that I\u0026rsquo;ll be able to keep it up for longer this time. :smirk:\nWhy Hugo? # So why, after so many colossal flops, am I switching to Hugo? It\u0026rsquo;s simple, really. The more times I make a failed attempt at blogging, the more I realize what I do and don\u0026rsquo;t want in my blogging toolset.\nThis is particularly true after my most recent blogging endeavor, and my first ever development blog. I had about a year of Python under my belt and fell for the myth that you need to build a hand-made portfolio website and also blog about your studies and projects in order to make a career change into the tech industry as a self-taught programmer.\nSo I did what any good aspiring data scientist does: built a mediocre HTML/CSS site from scratch, looked at Medium, got overwhelmed by the swarms of other data noobs pumping out articles for Towards Data Science, and promptly Googled—in full naïveté—\u0026ldquo;static site generator python\u0026rdquo;. From there, I found Pelican, found an extension that allowed me to write my blogs in Jupyter notebooks and went to town.\nI wouldn\u0026rsquo;t say my experience with Pelican was bad, but it wasn\u0026rsquo;t great either. I didn\u0026rsquo;t know a whole lot about development, deployment or GitHub when I set it up. GitHub Actions for a free build/deploy pipeline wasn\u0026rsquo;t really a thing yet. And, despite my best customization attempts, I just couldn\u0026rsquo;t find any themes that were nice, modern and had a dark mode. Add on the pressure of writing content with the aim of finding a job, and it just wasn\u0026rsquo;t an enjoyable experience overall. I made some cool visualizations that nobody will probably ever see, and wrote some mildly informational articles to help others at my skill level with data science tools, but in the end it was simply too much work.\nSince my last post in July 2020, I\u0026rsquo;ve been looking for a better way to blog. I researched and tried a number of different options, but ultimately Hugo won me over. Below is a list of my blogging criteria in case you find yourself in a similar position and are curious why I chose Hugo.\nThings I Want When I Blog # 1. Modern Theme # One of the big downsides of using Pelican was the lack of modern themes available. My last blog didn\u0026rsquo;t look terrible, but it also didn\u0026rsquo;t look modern. It looked fine. Pelican isn\u0026rsquo;t the only static site generator to suffer from this either. Jekyll, probably the biggest name in static site generators, also has a lot of \u0026ldquo;blah\u0026rdquo; themes. It has plenty of nice ones too, but the nicest ones usually cost, which is a deal breaker for me. Hugo, on the other hand, has enough modern and free themes that I had no trouble finding a suitable one with a quick search.\n2. Easily Customizable Theme # While some options have modern themes out of the box (like Medium), they\u0026rsquo;re either not customizable at all, or they\u0026rsquo;re a pain to customize. Jekyll and Pelican, for example, might have a way to customize your site to your liking, but there\u0026rsquo;s a good chance you have to have to look for extensions that achieve what you want. Between Hugo and the Congo theme, I have more flexibility and customizability than I\u0026rsquo;ll probably ever need baked right in.\n3. Syntax Highlighting # Perhaps surprisingly in 2022, built-in syntax highlighting with decent colors is harder to come by than you\u0026rsquo;d think. Some options have it built in, but you get terrible colors out of the box. Others require you to add an extension yourself. And worst of all, some (I\u0026rsquo;m looking at you, Medium :unamused:) have historically not supported syntax highlighting in code blocks and required you to link to a GitHub Gist instead.\nHugo comes with Chroma built in and I find the themed highlighting from Congo pleasant enough with a little tweaking and I trust my readers will as well.\ndef say_hello(name) puts \u0026#34;Hello, #{name}!\u0026#34; end 4. Ease of Use # One of the most important aspects for me is how easy it is to get from zero to published article. Some might argue that Hugo has a steeper learning curve than other SSGs, and that using a WYSIWYG editor like the one Medium provides is technically easier than having to style your work with Markdown and organize your own directory structure yourself.\nI won\u0026rsquo;t disagree with them.\nI will, however, say that in the long run (after the initial setup pains) it\u0026rsquo;s easier for me to get content out the door using the Markdown/Hugo/GH Pages/Actions flow publishing flow. I\u0026rsquo;ve been writing in Markdown for years now, whether it\u0026rsquo;s for code documentation or chatting on Discord and Slack. In fact, I\u0026rsquo;ve written far more in Markdown in the last few years than I have in a regular word processor. I also use Git and VS Code every day, so there\u0026rsquo;s no change of tooling required. Simply make a new file, write my thoughts, git add, git commit, git push.\nThat\u0026rsquo;s about as simple as it gets.\n5. Dark Mode for Reading and Writing # This one might seem like a simple ask, but I spend all day writing my code in a dark-themed editor and I simply can\u0026rsquo;t be expected to write a blog post on a glaringly white screen. Likewise, I anticipate most of my audience will be developers or people who write some code on a semi-regular basis and would appreciate a dark mode option when consuming my content.\nBlogging with Hugo allows me to write in VS Code with whatever color scheme I want, and publish to a site that allows easy switching between dark and light modes for my readers. What more can I ask for?\nThings I Don\u0026rsquo;t Want When I Blog # 1. Design My UI From Scratch # Despite the persistent lie that you are somehow a lesser developer if you don\u0026rsquo;t code your personal website/blog/portfolio from scratch, I have absolutely no desire to do this. The return on investment is low at best, and the cost is much higher than any other option.\nI am not a designer, and I\u0026rsquo;m perfectly comfortable with that fact. This blog is meant to be a vehicle for my thoughts and a reference for others (and my future self), so I\u0026rsquo;ll stick to what I\u0026rsquo;m good at and leave the beautifying to people who love that sort of thing. Thanks to the hard work of @jpanther, all I had to do to make this blog look beautiful was run the hugo mod init command and tweak a little bit of code git get it to my liking.\n2. Diminished Content Control # When I\u0026rsquo;m blogging, I want complete control of how and when I publish my work. I also don\u0026rsquo;t want to relinquish any rights to the content.\nAlthough the idea of submitting articles to some of the bigger programming publications on Medium, et al., to get readers is tempting, I can\u0026rsquo;t get on board with the fact that there are limitations on what I can write and how I\u0026rsquo;m allowed to write it. Sorry, not sorry—I\u0026rsquo;ll stick to self-publishing.\n3. Drag and Drop (or WYSIWYG) # I\u0026rsquo;ll admit there\u0026rsquo;s a certain appeal to blogging platforms with WYSIWYG editors and draggable images. I even strongly considered going with Ghost, which has both of those things and more. But ultimately, all of those things are non-essentials and usually come hand-in-hand with other restrictions that I\u0026rsquo;m not willing to accept. So for me, WYSIWYG isn\u0026rsquo;t a deal breaker (I might even consider Ghost again if I had no life and felt like hosting and maintaining my own instance of it), but it\u0026rsquo;s also not a selling point either.\n4. Change Software or Platform # I alluded to this above, but having to change software and/or platform in order to write blog posts comes at a cost. It\u0026rsquo;s one extra thing that I have to learn. One extra application that I have to open up on my computer. Sometimes more. If I can avoid this and write using the software I already use on a daily basis, I will. Hugo allows me to do this and that\u0026rsquo;s enough for me.\n5. Being Forced to Use Gists # Going hand and hand with syntax highlighting, a huge pet peeve of mine is not being able to include code directly in the blog post, instead requiring authors to put their code in a Gist and embed the Gist in the article. Last time I considered Medium, they were forcing writers to use Gists like this and it was probably the biggest turnoff of the platform for me.\nAlthough it looks like this may no longer be the case, it\u0026rsquo;s still something I look out for when comparing blogging options.\nConclusion # After months of considering the various options, I settled on Hugo. It works great for my needs, and it doesn\u0026rsquo;t have any of the negatives that I was trying to avoid. Whether it will help me get articles out to the world is anyone\u0026rsquo;s guess, but I\u0026rsquo;d be willing to bet that the reduction in technical and cognitive resistance will count for something.\n","date":"4 February 2022","permalink":"/posts/migrating-to-hugo/","section":"Posts","summary":"Over the years I\u0026rsquo;ve made several attempts to keep a blog, but they\u0026rsquo;ve all more or less fallen somewhere on the spectrum of failure.","title":"Migrating to Hugo"}]